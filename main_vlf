#!/bin/bash
#por si hay problemas de memoria con sac
#valgrind --tool=memcheck --leak-check=yes sac 

rm *.helm
rm *.in


#REDI_MT_BINDIR="/Users/edahi/Desktop/MTPACKAGE_new/MTCODE/BIN"
source  /home/edahi/bin/bin_ito/tdmt.config.linux
source  /home/edahi/.profile

echo $REDI_MT_BINDIR




my_string="Ubuntu;Linux Mint;Debian;Arch;Fedora"  
my_array=($(echo $my_string | tr ";" "\n"))

#Print the split string
for i in "${my_array[@]}"
do
    echo $i
done

echo $(pwd)


data_dir=$(pwd)
echo  $data_dir

ls  $data_dir/*.HHE.sac > listE
ls  $data_dir/*.HHN.sac > listN
ls  $data_dir/*.HHZ.sac > listZ


declare -a nameE 
declare -a nameN 
declare -a nameZ 


contE=0;
for next in `cat listE`
do
nameE[$contE]=$next
contE=$((contE+1))
done


contN=0;
for next in `cat listN`
do
nameN[$contN]=$next
contN=$((contN+1))
done


contZ=0;
for next in `cat listZ`
do
nameZ[$contZ]=$next
contZ=$((contZ+1))
done




if (($contN != $contE &&  $contN != $contZ && $contE != $contZ)); then
echo  not all N E Z components present.
exit
fi


echo ${nameE[1]}

year=2014
month=04
day=18
hour=14
min=27
sec=21

EVLA=$1
EVLO=$2
z=$3

MW=$4





echo $year $month $day $hour $min $sec $EVLA $EVLO $z $MW 


read op<<< `lesser_than $MW 4`

if [ ${op} = 1 ]
   then
  LCRN=.02
  HCRN=.1
fi



read op1<<< `greater_equal $MW 4`
read op2<<< `lesser_than $MW 5`

if [ ${op1} = 1 ] && [ ${op2} = 1 ]
   then

  LCRN=.02
  HCRN=.05

fi


read op1<<< `greater_equal $MW 5`
read op2<<< `lesser_than $MW 7.5`

if [ ${op1} = 1 ] && [ ${op2} = 1 ]
   then
  LCRN=.01
  HCRN=.05

fi


read op<<< `greater_equal $MW 7.5`

if [ ${op} = 1 ]
   then
  LCRN=.005
  HCRN=.02

fi

echo $LCRN $HCRN

  LCRN=0.005
  HCRN=0.02



DeltaT=$((300))


./copy_data_ssn $year $month $day $hour $min $sec $DeltaT








#crea el arreglo de las estaciones presentes

stat_list="${data_dir}/data/stat.list"
Nsta=0;
str_tmp=a

for next in `cat ${stat_list}`
do
#   IFS='_'  read -ra station_tmp  <<< $next
   
   station_tmp=($(echo $next | tr "_" "\n"))

   read op<<< `strcmp ${station_tmp[0]} ${str_tmp}`

   if [ ${op} = 0 ]
      then
      station[$Nsta]=${station_tmp[0]}
      Nsta=$((Nsta+1))
      str_tmp=${station_tmp[0]}
   fi
done


echo ${station[@]}
echo $Nsta

rm listE listN listZ


DT_int=1.0

for((k=0;k<$Nsta;k++))
do
./deconv ${station[k]}  $EVLA $EVLO $LCRN $HCRN $DT_int
done




ls  $data_dir/data/$year.$jday*.*HE.sac_deconv > listE_A
ls  $data_dir/data/$year.$jday*.*HN.sac_deconv > listN_A
ls  $data_dir/data/$year.$jday*.*HZ.sac_deconv > listZ_A




declare -a nameE 
declare -a nameN 
declare -a nameZ



contE=0;
for next in `cat listE_A`
do
nameE[$contE]=$next
contE=$((contE+1))
done


contN=0;
for next in `cat listN_A`
do
nameN[$contN]=$next
contN=$((contN+1))
done


contZ=0;
for next in `cat listZ_A`
do
nameZ[$contZ]=$next
contZ=$((contZ+1))
done




if (($contN != $contE &&  $contN != $contZ && $contE != $contZ)); then
echo  not all N E Z components present.
exit
fi


#echo ${nameE[@]}


#imprime la primera parte del archivo mt_inv.in


zcor=0
TWIND=250 


declare -a R_array

rm mt_inv.in
echo ${contE} $z 1 1 >> mt_inv.in



#calcula la distancia y el azimut

cont=0
for next in `cat listE_A`
do


echo `dist_azi_sac ${next}  ${EVLO} ${EVLA}`

delta_azimuth=($(echo `dist_azi_sac ${next}  ${EVLO} ${EVLA}` | tr " " "\n"))

echo ${delta_azimuth[@]}

IFS=' '  read  dist <<< `distance_sac ${next}  ${EVLO} ${EVLA}`
echo $dist

splited_E=($(echo ${nameE[cont]} | tr "." "\n"))
echo ${splited_E[@]}



R_array[${cont}]=${dist}
echo  ${splited_E[5]}.helm ${delta_azimuth[@]} ${zcor} $TWIND 
echo  ${splited_E[5]}.helm ${delta_azimuth[@]} ${zcor} $TWIND >> mt_inv.in
cont=$((${cont}+1))

done




numR=${cont}
echo numR: $numR






dir_gf=/home/edahi/Make_Green/gf_RO_BCS
gf_name="jp"





gf_in="MODEL.gil"
NN_GF=1024
DT_GF=0.5



for((k=0;k<$Nsta;k++))
do

R=${R_array[${k}]}
echo k $k  R $R

startdist=${R}
distitr=1
ddist=1


# Nombre del archivo esperado (ajusta según el formato real)
expected_file="${gf_name}${R}d${z}"
    
# Verificar si el archivo existe y tiene tamaño mayor que 0
if [ -s "$expected_file" ]; then
  echo "✓ Archivo $expected_file ya existe y no está vacío. Saltando cálculo."
  echo "${gf_name}${R_array[$k]}d$z 0 $TWIND" >> mt_inv.in
  continue
fi



echo model_exe ${gf_in}_$k $NN_GF $DT_GF $z $startdist $distitr $ddist

model_exe ${gf_in}_$k $NN_GF $DT_GF $z $startdist $distitr $ddist




rm GREEN.1

FKRPROG <${gf_in}_$k
run_fk2ascii $z $startdist  $distitr $ddist $NN_GF $DT_GF 
run_filt_syn $z $startdist $distitr $ddist $LCRN $HCRN  $NN_GF $(($NN_GF/2)) $DT_GF ${gf_name}  
     

# Verificar que el archivo se creó correctamente
if [ -s "$expected_file" ]; then
  echo "✓ Cálculo completado exitosamente: $expected_file"
  echo "${gf_name}${R_array[$k]}d$z 0 $TWIND" >> mt_inv.in
else
  echo "✗ Error: El archivo $expected_file no se creó correctamente"
fi

done






$REDI_MT_BINDIR/tdmt_invc>plot_$year$month$day$hour$min$sec

var=$(< results_var.out)


$REDI_MT_BINDIR/psigl<plot_$year$month$day$hour$min$sec>plot_var_${var}_$year$month$day${hour}_LA${EVLA}_LO${EVLO}_z${z}.ps

exit















